### Tell us about tools/techniques/conventions that worked well for your team. Explain why.
-------------------------------

  During the course of implementing the application we held scrum meetings twice a week and that allowed our team to keep track of what needed to get done, what was taking longer than usual and what was accomplished. As a result of this we were always aware of our progress and it was much easier to assign tasks to team members.

  Further, our team was a mixture of stronger and weaker programmers with varying levels of experience. To help share knowledge and implement features quickly, we held a half-day hackathon where the stronger programmers helped keep the team up to date with the codebase. This allowed the team to work more efficiently during the weekend.

### Tell us about tools/techniques/conventions that didn't work well for your team. Explain why.
-------------------------------

Our group was consistently developing the product using experimental web technologies, such as [ES6](https://github.com/lukehoban/es6features), introducing a very steep learning curve for the weaker programmers on the team. This meant that a lot of time had to be spent on making sure that all the developers on the team could remain productive.

### If you had to continue working as a team, and design your process, what would your process look like?
-------------------------------

With regards to future implementation, we would most likely proceed by extending upon our minimum viable product that we completed in phase 2, and begin development and implementation of features that we consider to be the most essential to our product. The three most important features to develop, extend and improve on would be the documentation sidebar, the auto-completion and the tutorial system. 

On top of this, we would also like to hold more half-day hackathons to work through problems together and give the weaker programmers time to try things out and learn, with guidance from the stronger members of the team. This would have been especially useful near the middle of the project, when the basics of the program had been implemented and previously written code needed to be extended to add new features.

Lastly, instead of directly allocating tasks to each group member we would also try doing more pair programming where we pair a member with a strong programming background with another member whose programming background is not as strong at the beginning of the development phase. This would allow all the team members to learn the newer technologies that we are using at the beginning and shorten the time it would take for the the team to learn them.

